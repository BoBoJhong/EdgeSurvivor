# 軟體設計文件 (架構設計)
## Software Design Document (SDD)

**專案名稱**: EdgeSurvivor (邊緣人神器)  
**版本**: 1.0  
**文件日期**: 2025年10月14日  
**作者**: 架構團隊  

---

## 目錄

1. [設計概述](#1-設計概述)
2. [系統架構設計](#2-系統架構設計)
3. [詳細設計](#3-詳細設計)
4. [資料庫設計](#4-資料庫設計)
5. [介面設計](#5-介面設計)
6. [安全設計](#6-安全設計)
7. [部署架構](#7-部署架構)

---

## 1. 設計概述

### 1.1 設計目標

-  **可擴展性**: 支援使用者數量和功能的增長
-  **可維護性**: 清晰的模組化設計，易於維護和修改
-  **高效能**: 快速回應，支援並發請求
-  **安全性**: 保護使用者資料和系統安全
-  **可測試性**: 便於單元測試和整合測試

### 1.2 設計原則

**SOLID 原則**:
- **S**ingle Responsibility: 單一職責
- **O**pen/Closed: 開放封閉
- **L**iskov Substitution: 里氏替換
- **I**nterface Segregation: 介面隔離
- **D**ependency Inversion: 依賴反轉

**其他原則**:
- DRY (Don't Repeat Yourself): 避免重複
- KISS (Keep It Simple, Stupid): 保持簡單
- YAGNI (You Aren't Gonna Need It): 只實現需要的功能

### 1.3 技術棧

**前端**:
- 框架: Vue 3 (Composition API)
- UI 庫: Element Plus
- 狀態管理: Pinia (選用)
- HTTP Client: Axios
- 即時通訊: Socket.IO Client
- 建置工具: Vite

**後端**:
- 框架: Flask (Python 3.9+)
- ORM: SQLAlchemy 2.x
- 認證: Flask-JWT-Extended
- 即時通訊: Flask-SocketIO
- 資料庫: MySQL 8.0+ / MariaDB 10.6+
- 快取: Redis (選用)

**DevOps**:
- 容器化: Docker + Docker Compose
- Web 伺服器: Nginx (反向代理)
- CI/CD: GitHub Actions
- 監控: Prometheus + Grafana (選用)

---

## 2. 系統架構設計

### 2.1 整體架構

EdgeSurvivor 採用 **三層架構 (Three-Tier Architecture)**:

\\\

                  Presentation Layer                  
              (Vue 3 + Element Plus)                  
   
    Pages   Components Services     Stores     
   

                      HTTP/WebSocket

                 Application Layer                    
                 (Flask REST API)                     
   
  Blueprints  Models   Services   Middleware   
   

                      SQLAlchemy

                   Data Layer                         
              (MySQL / MariaDB)                       
   
    Tables    Indexes    Views     Triggers    
   
─
\\\

### 2.2 架構模式

**MVC (Model-View-Controller)** 變體:

\\\
前端 (View)
     HTTP/WebSocket
後端 (Controller)
     SQLAlchemy ORM
資料庫 (Model)
\\\

**前端結構**:
\\\
src/
 views/          # 頁面組件 (View)
 components/     # 可重用組件
 services/       # API 服務層
 stores/         # 狀態管理 (Pinia)
 router/         # 路由配置
 utils/          # 工具函數
 assets/         # 靜態資源
\\\

**後端結構**:
\\\
backend/
 blueprints/     # 路由控制器 (Controller)
 models/         # 資料模型 (Model)
 services/       # 業務邏輯層
 utils/          # 工具函數
 middleware/     # 中間件
 app.py          # 應用進入點
\\\

### 2.3 模組劃分

| 模組 | 職責 | 技術 |
|------|------|------|
| 認證模組 | 註冊、登入、JWT 管理 | Flask-JWT-Extended |
| 使用者模組 | 個人資料、隱私設定 | SQLAlchemy User Model |
| 活動模組 | 活動 CRUD、搜尋、參與 | Activity + ActivityParticipant |
| 媒合模組 | 媒合申請、審核 | Match Model |
| 聊天模組 | 即時聊天、訊息管理 | Socket.IO + ChatMessage |
| 費用模組 | 費用記錄、分攤計算 | Expense Model |
| 上傳模組 | 圖片上傳、驗證 | Werkzeug FileStorage |

### 2.4 通訊機制

**RESTful API** (主要通訊方式):
\\\
GET    /api/activities          # 取得活動列表
POST   /api/activities          # 建立活動
GET    /api/activities/{id}     # 取得活動詳情
PUT    /api/activities/{id}     # 更新活動
DELETE /api/activities/{id}     # 刪除活動
\\\

**WebSocket** (即時通訊):
\\\javascript
// 連線
socket.connect()

// 加入聊天室
socket.emit('join_chat', { match_id: 123 })

// 發送訊息
socket.emit('send_message', {
  match_id: 123,
  content: 'Hello!'
})

// 接收訊息
socket.on('new_message', (data) => {
  console.log(data)
})
\\\

---

## 3. 詳細設計

### 3.1 認證系統設計

**JWT Token 機制**:

\\\
使用者登入
    
驗證帳密
    
生成 JWT Token
     Access Token (24h)
     Refresh Token (7d)
    
返回給前端
    
前端儲存 Token
     LocalStorage
     HTTP Header
    
後續請求帶 Token
    
後端驗證 Token
     有效: 允許訪問
     無效: 401 Unauthorized
\\\

**Token 結構**:
\\\json
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "sub": "123",           # 使用者 ID
    "exp": 1734192000,      # 過期時間
    "iat": 1734105600,      # 簽發時間
    "type": "access"        # Token 類型
  },
  "signature": "..."
}
\\\

**刷新機制**:
\\\
Access Token 過期
    
前端使用 Refresh Token
    
POST /api/auth/refresh
    
後端驗證 Refresh Token
     有效: 生成新 Access Token
     無效: 要求重新登入
\\\

### 3.2 活動管理設計

**活動生命週期**:

\\\
[建立]  [開放]  [進行中]  [已完成]
                      
        [已取消]   [已取消]
\\\

**參與流程**:

\\\
使用者申請參與
    
status = 'pending'
    
創建者審核
     接受  status = 'approved'  加入活動
     拒絕  status = 'rejected'  結束
\\\

**搜尋設計**:

\\\python
# 動態查詢建構
query = Activity.query

if keyword:
    query = query.filter(Activity.title.contains(keyword))

if date_from:
    query = query.filter(Activity.date >= date_from)

if location:
    query = query.filter(Activity.location == location)

if category:
    query = query.filter(Activity.category == category)

# 分頁
activities = query.paginate(page=1, per_page=12)
\\\

### 3.3 媒合系統設計

**媒合狀態機**:

\\\
[pending]
     接受  [accepted]  開啟聊天室
     拒絕  [rejected]
     取消  [cancelled]
\\\

**推薦演算法** (簡化版):

\\\python
def recommend_matches(user):
    # 1. 共同活動的參與者
    common_activities = get_common_activities(user)
    
    # 2. 興趣相似度計算
    interest_score = calculate_interest_similarity(user)
    
    # 3. 地區相近
    location_score = calculate_location_proximity(user)
    
    # 4. 綜合評分
    total_score = (
        common_activities * 0.5 +
        interest_score * 0.3 +
        location_score * 0.2
    )
    
    return sorted_by_score(total_score)
\\\

### 3.4 聊天系統設計

**Socket.IO 事件流**:

\\\
客戶端 A                      伺服器                      客戶端 B
                                                            
     connect()                              
                                                            
     join_chat(match_id)                              
                                 驗證權限                   
                                 加入 Room                  
                                                            
     send_message()                              
                                 儲存訊息到DB              
                                 broadcast  
                                                             顯示訊息
                                                            
                                  mark_as_read() 
      message_read                             
     更新已讀狀態                                           
\\\

**訊息持久化**:
- 即時: Socket.IO 推送
- 持久: 儲存到 chat_messages 表
- 同步: 離線時查詢歷史訊息

### 3.5 費用分攤設計

**債務優化演算法**:

\\\python
def calculate_settlement(expenses, participants):
    # 1. 計算每人淨餘額
    balances = {}
    total_cost = sum(e.amount for e in expenses)
    per_person = total_cost / len(participants)
    
    for participant in participants:
        paid = sum(e.amount for e in expenses if e.payer_id == participant.id)
        balances[participant.id] = paid - per_person
    
    # 2. 分離債權人和債務人
    creditors = [(k, v) for k, v in balances.items() if v > 0]
    debtors = [(k, v) for k, v in balances.items() if v < 0]
    
    # 3. 配對結算
    transactions = []
    while creditors and debtors:
        creditor_id, credit = creditors.pop()
        debtor_id, debt = debtors.pop()
        
        amount = min(credit, abs(debt))
        transactions.append({
            'from': debtor_id,
            'to': creditor_id,
            'amount': amount
        })
        
        # 更新餘額
        if credit > abs(debt):
            creditors.append((creditor_id, credit - amount))
        elif abs(debt) > credit:
            debtors.append((debtor_id, debt + amount))
    
    return transactions
\\\

---

## 4. 資料庫設計

### 4.1 ER 圖 (Entity-Relationship Diagram)

\\\
              
  Users  1n   Activities  n1   Users   
              
                                        (creator)
     1                  n
                        
     n            
                  ActivityParticipants 
                  
     
     1
     
       
 Matches 1n ChatMessages  
       
     
     n
     

  Expenses   

\\\

### 4.2 資料表設計

詳見《物件設計文件》第 4 節。

### 4.3 索引設計

**效能優化索引**:

\\\sql
-- users 表
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_location ON users(location);

-- activities 表
CREATE INDEX idx_activities_date ON activities(date);
CREATE INDEX idx_activities_location ON activities(location);
CREATE INDEX idx_activities_category ON activities(category);
CREATE INDEX idx_activities_creator_id ON activities(creator_id);

-- matches 表
CREATE INDEX idx_matches_user_a ON matches(user_a);
CREATE INDEX idx_matches_user_b ON matches(user_b);
CREATE INDEX idx_matches_status ON matches(status);

-- chat_messages 表
CREATE INDEX idx_chat_messages_match_id ON chat_messages(match_id);
CREATE INDEX idx_chat_messages_sender_id ON chat_messages(sender_id);
CREATE INDEX idx_chat_messages_timestamp ON chat_messages(timestamp);
\\\

### 4.4 資料完整性

**外鍵約束**:
\\\sql
ALTER TABLE activities
ADD CONSTRAINT fk_activities_creator
FOREIGN KEY (creator_id) REFERENCES users(user_id)
ON DELETE CASCADE;

ALTER TABLE matches
ADD CONSTRAINT fk_matches_user_a
FOREIGN KEY (user_a) REFERENCES users(user_id)
ON DELETE CASCADE;
\\\

**唯一約束**:
\\\sql
ALTER TABLE users
ADD CONSTRAINT uk_users_email
UNIQUE (email);

ALTER TABLE activity_participants
ADD CONSTRAINT uk_activity_participants
UNIQUE (activity_id, user_id);
\\\

---

## 5. 介面設計

### 5.1 API 設計規範

**RESTful 原則**:
- 使用名詞表示資源: /activities 而非 /getActivities
- 使用 HTTP 方法表示動作: GET, POST, PUT, DELETE
- 使用 HTTP 狀態碼: 200, 201, 400, 401, 404, 500

**URL 命名規範**:
\\\
/api/{resource}                # 集合
/api/{resource}/{id}           # 單個資源
/api/{resource}/{id}/{action}  # 資源的操作
\\\

**請求/回應格式**:

請求:
\\\json
{
  "title": "台北登山活動",
  "date": "2025-11-01",
  "location": "台北市"
}
\\\

成功回應:
\\\json
{
  "status": "success",
  "data": {
    "activity_id": 123,
    "title": "台北登山活動"
  }
}
\\\

錯誤回應:
\\\json
{
  "status": "error",
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "活動標題不能為空",
    "field": "title"
  }
}
\\\

### 5.2 API 端點清單

詳見 Task.md 第 7 節「已實作的 API 端點」。

### 5.3 前端路由設計

\\\javascript
const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home
  },
  {
    path: '/login',
    name: 'Login',
    component: Login
  },
  {
    path: '/activities',
    name: 'Activities',
    component: Activities,
    meta: { requiresAuth: true }
  },
  {
    path: '/activities/:id',
    name: 'ActivityDetail',
    component: ActivityDetail,
    meta: { requiresAuth: true }
  },
  {
    path: '/matches',
    name: 'Matches',
    component: Matches,
    meta: { requiresAuth: true }
  },
  {
    path: '/chat',
    name: 'Chat',
    component: Chat,
    meta: { requiresAuth: true }
  },
  {
    path: '/profile',
    name: 'Profile',
    component: Profile,
    meta: { requiresAuth: true }
  }
]
\\\

**路由守衛**:
\\\javascript
router.beforeEach((to, from, next) => {
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth)
  const token = localStorage.getItem('token')
  
  if (requiresAuth && !token) {
    next('/login')
  } else {
    next()
  }
})
\\\

---

## 6. 安全設計

### 6.1 認證與授權

**密碼安全**:
- 使用 bcrypt Hash (cost factor = 12)
- Salt 自動生成
- 永不明文儲存密碼

**Token 安全**:
- JWT 簽名驗證
- Token 有效期限制
- Refresh Token 輪換機制

**權限控制**:
\\\python
from functools import wraps
from flask_jwt_extended import get_jwt_identity, jwt_required

def creator_required(f):
    @wraps(f)
    @jwt_required()
    def decorated_function(*args, **kwargs):
        activity_id = kwargs.get('activity_id')
        current_user_id = int(get_jwt_identity())
        activity = Activity.query.get(activity_id)
        
        if activity.creator_id != current_user_id:
            return jsonify({'error': '無權限'}), 403
        
        return f(*args, **kwargs)
    
    return decorated_function

@activities_bp.route('/<int:activity_id>', methods=['DELETE'])
@creator_required
def delete_activity(activity_id):
    # 只有創建者可以刪除
    pass
\\\

### 6.2 輸入驗證

**前端驗證**:
\\\javascript
const validateEmail = (email) => {
  const re = /^[^\s@]+@[^\s@]+\.[^\s@]+\$/
  return re.test(email)
}

const validatePassword = (password) => {
  return password.length >= 8 && /[A-Za-z]/.test(password) && /\d/.test(password)
}
\\\

**後端驗證**:
\\\python
from marshmallow import Schema, fields, validate, validates, ValidationError

class ActivitySchema(Schema):
    title = fields.Str(required=True, validate=validate.Length(min=5, max=100))
    date = fields.Date(required=True)
    location = fields.Str(required=True)
    category = fields.Str(validate=validate.OneOf(['冒險', '文化', '休閒', '運動', '美食']))
    
    @validates('date')
    def validate_date(self, value):
        if value < datetime.now().date():
            raise ValidationError('活動日期不能是過去')
\\\

### 6.3 防護措施

**SQL Injection 防護**:
- 使用 SQLAlchemy ORM 參數化查詢
- 永不拼接 SQL 字串

**XSS 防護**:
- 前端輸出轉義
- Content-Security-Policy Header

**CSRF 防護**:
- CSRF Token 驗證
- SameSite Cookie 屬性

**Rate Limiting**:
\\\python
from flask_limiter import Limiter

limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["100 per minute"]
)

@app.route('/api/login', methods=['POST'])
@limiter.limit("5 per minute")
def login():
    pass
\\\

---

## 7. 部署架構

### 7.1 開發環境

\\\yaml
version: '3.8'

services:
  db:
    image: mariadb:10.6
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: edgesurvivor
    ports:
      - "3306:3306"
  
  backend:
    build: ./backend
    ports:
      - "5000:5000"
    depends_on:
      - db
    environment:
      DATABASE_URL: mysql://root:root@db/edgesurvivor
  
  frontend:
    build: ./frontend
    ports:
      - "5173:5173"
    depends_on:
      - backend
\\\

### 7.2 生產環境

\\\
[使用者] 
    HTTPS
[CloudFlare CDN]
   
[Nginx (反向代理 + SSL)]
    /api  [Flask Backend]  N (負載平衡)
    /socket.io  [Socket.IO]  N
    /  [Static Files (Vue SPA)]
   
[Flask Backend]
   
[MySQL Master/Slave]
    Master (Write)
    Slave (Read)
   
[Redis Cache] (選用)
\\\

**Nginx 配置範例**:
\\\
ginx
upstream backend {
    server backend1:5000;
    server backend2:5000;
}

server {
    listen 443 ssl;
    server_name edgesurvivor.com;
    
    ssl_certificate /etc/ssl/cert.pem;
    ssl_certificate_key /etc/ssl/key.pem;
    
    # API 代理
    location /api/ {
        proxy_pass http://backend;
        proxy_set_header Host \System.Management.Automation.Internal.Host.InternalHost;
        proxy_set_header X-Real-IP \;
    }
    
    # WebSocket 代理
    location /socket.io/ {
        proxy_pass http://backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \;
        proxy_set_header Connection "upgrade";
    }
    
    # 靜態檔案
    location / {
        root /var/www/html;
        try_files \ \/ /index.html;
    }
}
\\\

### 7.3 CI/CD 流程

\\\yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run Tests
        run: |
          cd backend
          pip install -r requirements.txt
          pytest
  
  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Build Docker Images
        run: |
          docker build -t edgesurvivor-backend ./backend
          docker build -t edgesurvivor-frontend ./frontend
  
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Server
        run: |
          ssh user@server 'cd /app && docker-compose pull && docker-compose up -d'
\\\

---

## 附錄 A: 設計模式應用

### A.1 Singleton Pattern (單例模式)
- 資料庫連線: SQLAlchemy Session
- Socket.IO 實例

### A.2 Factory Pattern (工廠模式)
- Blueprint 工廠: 建立不同的 API Blueprint

### A.3 Decorator Pattern (裝飾器模式)
- JWT 認證裝飾器: @jwt_required()
- 權限驗證裝飾器: @creator_required

### A.4 Observer Pattern (觀察者模式)
- Socket.IO 事件監聽: on('event', callback)

---

## 附錄 B: 效能優化策略

### B.1 資料庫優化
- 適當的索引
- 查詢優化 (避免 N+1 問題)
- 連線池管理

### B.2 快取策略
- Redis 快取熱門資料
- HTTP 快取 Header
- CDN 快取靜態資源

### B.3 前端優化
- 程式碼分割 (Code Splitting)
- 懶載入 (Lazy Loading)
- 圖片優化 (WebP, 壓縮)

---

## 附錄 C: 變更歷史

| 版本 | 日期 | 作者 | 變更內容 |
|------|------|------|----------|
| 1.0 | 2025-10-14 | 架構團隊 | 初始版本 |

---

**文件結束**
